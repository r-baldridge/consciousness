#!/usr/bin/env python3
"""
Integrated Information Theory (IIT) Consciousness Interface

Form 13: Implements Integrated Information Theory as proposed by Giulio Tononi.
IIT posits that consciousness corresponds to integrated information (phi) -
the amount of information generated by a complex of elements above and beyond
its parts. A system is conscious to the degree that it is a single, integrated
entity with a large repertoire of distinguishable states.

This module computes phi (integrated information), identifies irreducible
cause-effect structures, finds the main complex, and builds the conceptual
structure that characterizes conscious experience according to IIT.
"""

import asyncio
import logging
import math
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple

logger = logging.getLogger(__name__)


# ============================================================================
# ENUMERATIONS
# ============================================================================

class IntegrationLevel(Enum):
    """
    Levels of information integration in a system.

    These levels characterize how much integrated information
    the system generates, mapping to different degrees of consciousness.
    """
    NONE = "none"              # phi = 0: No integration, no consciousness
    MINIMAL = "minimal"        # phi < 0.2: Very low integration
    LOW = "low"                # phi 0.2-0.4: Some integration
    MODERATE = "moderate"      # phi 0.4-0.6: Moderate integration
    HIGH = "high"              # phi 0.6-0.8: Significant integration
    VERY_HIGH = "very_high"    # phi 0.8-1.0: Very high integration
    MAXIMAL = "maximal"        # phi >= 1.0: Maximum integration


class ComplexType(Enum):
    """Types of complexes in the IIT framework."""
    MAIN_COMPLEX = "main_complex"        # The complex with highest phi
    SUB_COMPLEX = "sub_complex"          # A complex within the main complex
    BACKGROUND = "background"            # Elements not in the main complex
    ISOLATED = "isolated"                # Disconnected elements


class CauseEffectStructure(Enum):
    """Types of cause-effect structures (concepts)."""
    CAUSE = "cause"                      # Past-facing (cause repertoire)
    EFFECT = "effect"                    # Future-facing (effect repertoire)
    CAUSE_EFFECT = "cause_effect"        # Full cause-effect repertoire
    NULL = "null"                        # No cause-effect power


class PartitionType(Enum):
    """Types of system partitions for phi computation."""
    UNIDIRECTIONAL_CUT = "unidirectional_cut"  # Sever connections in one direction
    BIDIRECTIONAL_CUT = "bidirectional_cut"    # Sever connections in both directions
    MINIMUM_PARTITION = "minimum_partition"      # The partition that minimizes phi


class ExperienceQuality(Enum):
    """Qualities of experience according to IIT."""
    INTRINSIC = "intrinsic"          # Experience exists for the system itself
    STRUCTURED = "structured"         # Experience has compositional structure
    SPECIFIC = "specific"            # Experience is particular/definite
    UNIFIED = "unified"              # Experience is a unified whole
    DEFINITE = "definite"            # Experience has definite borders


# ============================================================================
# DATA CLASSES - INPUTS
# ============================================================================

@dataclass
class SystemElement:
    """A single element in the IIT system."""
    element_id: str
    state: int                         # Current binary state (0 or 1)
    label: str = ""
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def to_dict(self) -> Dict[str, Any]:
        return {
            "element_id": self.element_id,
            "state": self.state,
            "label": self.label,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class IITInput:
    """Input data for IIT computation."""
    system_state: List[int]                    # Current state of all elements
    connectivity_matrix: List[List[float]]     # Connection weights between elements
    element_labels: List[str] = field(default_factory=list)
    transition_probability_matrix: Optional[List[List[float]]] = None
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def to_dict(self) -> Dict[str, Any]:
        return {
            "system_state": self.system_state,
            "connectivity_matrix": self.connectivity_matrix,
            "element_labels": self.element_labels,
            "has_tpm": self.transition_probability_matrix is not None,
            "num_elements": len(self.system_state),
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class Partition:
    """A partition of a system into two parts."""
    part_a: List[int]                  # Indices of elements in part A
    part_b: List[int]                  # Indices of elements in part B
    partition_type: PartitionType = PartitionType.UNIDIRECTIONAL_CUT
    severed_connections: List[Tuple[int, int]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "part_a": self.part_a,
            "part_b": self.part_b,
            "partition_type": self.partition_type.value,
            "severed_connections": self.severed_connections,
        }


# ============================================================================
# DATA CLASSES - OUTPUTS
# ============================================================================

@dataclass
class Concept:
    """A concept in the IIT conceptual structure."""
    mechanism: List[int]               # The mechanism (subset of elements)
    cause_repertoire: Dict[str, float] # Probability distribution over past states
    effect_repertoire: Dict[str, float] # Probability distribution over future states
    phi_cause: float                   # Integrated information of cause
    phi_effect: float                  # Integrated information of effect
    phi: float                         # Small phi of the concept (min of cause/effect)
    structure_type: CauseEffectStructure = CauseEffectStructure.CAUSE_EFFECT

    def to_dict(self) -> Dict[str, Any]:
        return {
            "mechanism": self.mechanism,
            "phi_cause": round(self.phi_cause, 6),
            "phi_effect": round(self.phi_effect, 6),
            "phi": round(self.phi, 6),
            "structure_type": self.structure_type.value,
        }


@dataclass
class ConceptualStructure:
    """The full conceptual structure (constellation of concepts)."""
    concepts: List[Concept]
    num_concepts: int
    total_phi: float                   # Sum of all concept phi values
    structure_signature: str = ""      # Unique signature of the structure

    def to_dict(self) -> Dict[str, Any]:
        return {
            "num_concepts": self.num_concepts,
            "total_phi": round(self.total_phi, 6),
            "concepts": [c.to_dict() for c in self.concepts],
            "structure_signature": self.structure_signature,
        }


@dataclass
class Complex:
    """A complex identified in the system."""
    elements: List[int]                # Indices of elements in the complex
    phi: float                         # Big Phi of the complex
    complex_type: ComplexType
    conceptual_structure: Optional[ConceptualStructure] = None
    is_main: bool = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "elements": self.elements,
            "phi": round(self.phi, 6),
            "complex_type": self.complex_type.value,
            "is_main": self.is_main,
            "has_conceptual_structure": self.conceptual_structure is not None,
        }


@dataclass
class IITOutput:
    """Complete output from IIT computation."""
    phi: float                         # Big Phi of the main complex
    integration_level: IntegrationLevel
    main_complex: Complex
    all_complexes: List[Complex]
    conceptual_structure: ConceptualStructure
    minimum_partition: Partition
    experience_qualities: List[ExperienceQuality]
    num_elements: int
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def to_dict(self) -> Dict[str, Any]:
        return {
            "phi": round(self.phi, 6),
            "integration_level": self.integration_level.value,
            "main_complex": self.main_complex.to_dict(),
            "num_complexes": len(self.all_complexes),
            "conceptual_structure": self.conceptual_structure.to_dict(),
            "minimum_partition": self.minimum_partition.to_dict(),
            "experience_qualities": [q.value for q in self.experience_qualities],
            "num_elements": self.num_elements,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class IITSystemStatus:
    """Status of the IIT computation system."""
    is_initialized: bool
    last_computation: Optional[IITOutput]
    computation_count: int
    average_phi: float
    system_health: float
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


# ============================================================================
# IIT COMPUTATION ENGINE
# ============================================================================

class IITComputationEngine:
    """
    Core computation engine for Integrated Information Theory.

    Implements phi computation, concept identification, and
    conceptual structure construction according to IIT 3.0.
    """

    def __init__(self):
        self._computation_cache: Dict[str, float] = {}

    def compute_phi_for_subset(
        self,
        subset: List[int],
        system_state: List[int],
        connectivity: List[List[float]]
    ) -> float:
        """
        Compute phi (integrated information) for a subset of elements.

        Uses the connectivity matrix to estimate information integration.
        Higher connectivity and mutual dependence yield higher phi.
        """
        if len(subset) < 2:
            return 0.0

        # Compute integration as a function of internal connectivity
        internal_strength = 0.0
        connection_count = 0

        for i in subset:
            for j in subset:
                if i != j:
                    weight = connectivity[i][j] if i < len(connectivity) and j < len(connectivity[i]) else 0.0
                    internal_strength += abs(weight)
                    connection_count += 1

        if connection_count == 0:
            return 0.0

        avg_internal = internal_strength / connection_count

        # Find the minimum information partition (MIP)
        min_partition_loss = float('inf')
        n = len(subset)

        if n <= 1:
            return 0.0

        # Try all bipartitions
        for cut_size in range(1, n):
            for part_a_indices in self._combinations(list(range(n)), cut_size):
                part_b_indices = [i for i in range(n) if i not in part_a_indices]
                if not part_b_indices:
                    continue

                part_a = [subset[i] for i in part_a_indices]
                part_b = [subset[i] for i in part_b_indices]

                # Compute information lost by partition
                cross_info = 0.0
                cross_count = 0
                for a in part_a:
                    for b in part_b:
                        if a < len(connectivity) and b < len(connectivity[a]):
                            cross_info += abs(connectivity[a][b])
                        if b < len(connectivity) and a < len(connectivity[b]):
                            cross_info += abs(connectivity[b][a])
                        cross_count += 2

                if cross_count > 0:
                    partition_loss = cross_info / cross_count
                else:
                    partition_loss = 0.0

                min_partition_loss = min(min_partition_loss, partition_loss)

        if min_partition_loss == float('inf'):
            min_partition_loss = 0.0

        # Phi is the information lost by the minimum partition
        # Scaled by the state-dependent activation
        state_activation = sum(system_state[i] for i in subset if i < len(system_state)) / max(1, len(subset))
        phi = min_partition_loss * (0.5 + 0.5 * state_activation) * avg_internal

        return max(0.0, phi)

    def compute_concept(
        self,
        mechanism: List[int],
        system_state: List[int],
        connectivity: List[List[float]]
    ) -> Concept:
        """Compute a single concept for a mechanism over a purview."""
        n = len(system_state)

        # Compute cause repertoire (past-facing)
        cause_repertoire = {}
        cause_phi = 0.0
        for i in mechanism:
            incoming = sum(
                abs(connectivity[j][i]) for j in range(n)
                if j < len(connectivity) and i < len(connectivity[j])
            )
            cause_repertoire[str(i)] = incoming / max(1.0, n)
            cause_phi += incoming

        cause_phi = cause_phi / max(1.0, n * len(mechanism)) if mechanism else 0.0

        # Compute effect repertoire (future-facing)
        effect_repertoire = {}
        effect_phi = 0.0
        for i in mechanism:
            outgoing = sum(
                abs(connectivity[i][j]) for j in range(n)
                if i < len(connectivity) and j < len(connectivity[i])
            )
            effect_repertoire[str(i)] = outgoing / max(1.0, n)
            effect_phi += outgoing

        effect_phi = effect_phi / max(1.0, n * len(mechanism)) if mechanism else 0.0

        # Small phi is the minimum of cause and effect phi
        phi = min(cause_phi, effect_phi)

        structure_type = CauseEffectStructure.CAUSE_EFFECT
        if phi == 0.0:
            structure_type = CauseEffectStructure.NULL
        elif cause_phi > effect_phi * 2:
            structure_type = CauseEffectStructure.CAUSE
        elif effect_phi > cause_phi * 2:
            structure_type = CauseEffectStructure.EFFECT

        return Concept(
            mechanism=mechanism,
            cause_repertoire=cause_repertoire,
            effect_repertoire=effect_repertoire,
            phi_cause=cause_phi,
            phi_effect=effect_phi,
            phi=phi,
            structure_type=structure_type,
        )

    def find_minimum_partition(
        self,
        elements: List[int],
        connectivity: List[List[float]]
    ) -> Partition:
        """Find the minimum information partition of the system."""
        n = len(elements)
        if n < 2:
            return Partition(
                part_a=elements,
                part_b=[],
                partition_type=PartitionType.MINIMUM_PARTITION,
            )

        best_partition = None
        min_cross_info = float('inf')

        for cut_size in range(1, n):
            for part_a_indices in self._combinations(list(range(n)), cut_size):
                part_b_indices = [i for i in range(n) if i not in part_a_indices]
                if not part_b_indices:
                    continue

                part_a = [elements[i] for i in part_a_indices]
                part_b = [elements[i] for i in part_b_indices]

                cross_info = 0.0
                severed = []
                for a in part_a:
                    for b in part_b:
                        if a < len(connectivity) and b < len(connectivity[a]):
                            cross_info += abs(connectivity[a][b])
                            if abs(connectivity[a][b]) > 0:
                                severed.append((a, b))

                if cross_info < min_cross_info:
                    min_cross_info = cross_info
                    best_partition = Partition(
                        part_a=part_a,
                        part_b=part_b,
                        partition_type=PartitionType.MINIMUM_PARTITION,
                        severed_connections=severed,
                    )

        if best_partition is None:
            mid = n // 2
            best_partition = Partition(
                part_a=elements[:mid],
                part_b=elements[mid:],
                partition_type=PartitionType.MINIMUM_PARTITION,
            )

        return best_partition

    def _combinations(self, items: List[int], k: int) -> List[List[int]]:
        """Generate all combinations of k items (limited for performance)."""
        if k == 0:
            return [[]]
        if k > len(items):
            return []
        # Limit combinatorial explosion
        if len(items) > 10 and k > 2:
            return [items[:k]]

        result = []
        for i in range(len(items)):
            for rest in self._combinations(items[i + 1:], k - 1):
                result.append([items[i]] + rest)
        return result

    def classify_integration_level(self, phi: float) -> IntegrationLevel:
        """Classify phi value into integration level."""
        if phi <= 0.0:
            return IntegrationLevel.NONE
        elif phi < 0.2:
            return IntegrationLevel.MINIMAL
        elif phi < 0.4:
            return IntegrationLevel.LOW
        elif phi < 0.6:
            return IntegrationLevel.MODERATE
        elif phi < 0.8:
            return IntegrationLevel.HIGH
        elif phi < 1.0:
            return IntegrationLevel.VERY_HIGH
        else:
            return IntegrationLevel.MAXIMAL

    def determine_experience_qualities(self, phi: float, conceptual_structure: ConceptualStructure) -> List[ExperienceQuality]:
        """Determine which experience qualities are present based on IIT axioms."""
        qualities = []

        if phi > 0.0:
            qualities.append(ExperienceQuality.INTRINSIC)

        if conceptual_structure.num_concepts > 1:
            qualities.append(ExperienceQuality.STRUCTURED)

        if phi > 0.2:
            qualities.append(ExperienceQuality.SPECIFIC)

        if phi > 0.4:
            qualities.append(ExperienceQuality.UNIFIED)

        if phi > 0.1:
            qualities.append(ExperienceQuality.DEFINITE)

        return qualities


# ============================================================================
# MAIN INTERFACE CLASS
# ============================================================================

class IITConsciousnessInterface:
    """
    Main interface for Form 13: Integrated Information Theory.

    Implements IIT's approach to consciousness, computing phi
    (integrated information) to quantify the degree of consciousness
    in a system, identifying the main complex, and constructing
    the conceptual structure that specifies the quality of experience.
    """

    FORM_ID = "13-integrated-information"
    FORM_NAME = "Integrated Information Theory (IIT)"

    def __init__(self):
        """Initialize the IIT consciousness interface."""
        self._engine = IITComputationEngine()
        self._is_initialized = False
        self._last_output: Optional[IITOutput] = None
        self._computation_count = 0
        self._phi_history: List[float] = []
        self._max_history = 100

        logger.info(f"Initialized {self.FORM_NAME}")

    async def initialize(self) -> None:
        """Initialize the IIT system."""
        self._is_initialized = True
        logger.info(f"{self.FORM_NAME} initialized and ready")

    async def compute_phi(self, iit_input: IITInput) -> IITOutput:
        """
        Compute integrated information (phi) for the given system.

        This is the main entry point for IIT computation. It identifies
        the main complex, computes its phi value, and constructs the
        conceptual structure.
        """
        n = len(iit_input.system_state)
        connectivity = iit_input.connectivity_matrix

        # Find all complexes
        all_complexes = self._find_all_complexes(
            iit_input.system_state, connectivity, n
        )

        # Identify the main complex (highest phi)
        if all_complexes:
            main_complex = max(all_complexes, key=lambda c: c.phi)
            main_complex.is_main = True
            main_complex.complex_type = ComplexType.MAIN_COMPLEX
        else:
            main_complex = Complex(
                elements=list(range(n)),
                phi=0.0,
                complex_type=ComplexType.MAIN_COMPLEX,
                is_main=True,
            )
            all_complexes = [main_complex]

        # Build conceptual structure for the main complex
        conceptual_structure = await self.get_conceptual_structure(
            main_complex.elements, iit_input
        )
        main_complex.conceptual_structure = conceptual_structure

        # Find minimum partition
        min_partition = self._engine.find_minimum_partition(
            main_complex.elements, connectivity
        )

        # Determine integration level
        integration_level = self._engine.classify_integration_level(main_complex.phi)

        # Determine experience qualities
        experience_qualities = self._engine.determine_experience_qualities(
            main_complex.phi, conceptual_structure
        )

        output = IITOutput(
            phi=main_complex.phi,
            integration_level=integration_level,
            main_complex=main_complex,
            all_complexes=all_complexes,
            conceptual_structure=conceptual_structure,
            minimum_partition=min_partition,
            experience_qualities=experience_qualities,
            num_elements=n,
        )

        # Update internal state
        self._last_output = output
        self._computation_count += 1
        self._phi_history.append(output.phi)
        if len(self._phi_history) > self._max_history:
            self._phi_history.pop(0)

        return output

    async def get_conceptual_structure(
        self, elements: List[int], iit_input: IITInput
    ) -> ConceptualStructure:
        """
        Build the conceptual structure for a set of elements.

        The conceptual structure is a constellation of concepts,
        each specifying a cause-effect repertoire.
        """
        concepts = []

        # Generate concepts for all non-empty subsets (limited)
        for size in range(1, min(len(elements) + 1, 5)):
            for subset in self._engine._combinations(elements, size):
                concept = self._engine.compute_concept(
                    subset, iit_input.system_state, iit_input.connectivity_matrix
                )
                if concept.phi > 0.0:
                    concepts.append(concept)

        total_phi = sum(c.phi for c in concepts)

        # Create structure signature
        sig_parts = [f"{c.mechanism}:{c.phi:.4f}" for c in sorted(concepts, key=lambda c: -c.phi)[:5]]
        signature = "|".join(sig_parts)

        return ConceptualStructure(
            concepts=concepts,
            num_concepts=len(concepts),
            total_phi=total_phi,
            structure_signature=signature,
        )

    async def identify_main_complex(self, iit_input: IITInput) -> Complex:
        """
        Identify the main complex of the system.

        The main complex is the subset of elements with the highest
        integrated information (phi).
        """
        output = await self.compute_phi(iit_input)
        return output.main_complex

    async def get_integration_structure(self, iit_input: IITInput) -> Dict[str, Any]:
        """
        Get a detailed view of the system's integration structure.

        Returns information about how different parts of the system
        contribute to overall integration.
        """
        n = len(iit_input.system_state)
        connectivity = iit_input.connectivity_matrix

        # Element-level analysis
        element_contributions = {}
        for i in range(n):
            incoming = sum(abs(connectivity[j][i]) for j in range(n) if j < len(connectivity) and i < len(connectivity[j]))
            outgoing = sum(abs(connectivity[i][j]) for j in range(n) if i < len(connectivity) and j < len(connectivity[i]))
            label = iit_input.element_labels[i] if i < len(iit_input.element_labels) else f"element_{i}"
            element_contributions[label] = {
                "incoming_strength": round(incoming, 4),
                "outgoing_strength": round(outgoing, 4),
                "total_connectivity": round(incoming + outgoing, 4),
                "state": iit_input.system_state[i],
            }

        # Pairwise integration
        pairwise = {}
        for i in range(n):
            for j in range(i + 1, n):
                pair_phi = self._engine.compute_phi_for_subset(
                    [i, j], iit_input.system_state, connectivity
                )
                label_i = iit_input.element_labels[i] if i < len(iit_input.element_labels) else f"e{i}"
                label_j = iit_input.element_labels[j] if j < len(iit_input.element_labels) else f"e{j}"
                pairwise[f"{label_i}-{label_j}"] = round(pair_phi, 6)

        # System-level phi
        system_phi = self._engine.compute_phi_for_subset(
            list(range(n)), iit_input.system_state, connectivity
        )

        return {
            "system_phi": round(system_phi, 6),
            "num_elements": n,
            "element_contributions": element_contributions,
            "pairwise_integration": pairwise,
            "integration_level": self._engine.classify_integration_level(system_phi).value,
        }

    def _find_all_complexes(
        self,
        system_state: List[int],
        connectivity: List[List[float]],
        n: int
    ) -> List[Complex]:
        """Find all complexes in the system."""
        complexes = []

        # Check the full system
        full_phi = self._engine.compute_phi_for_subset(
            list(range(n)), system_state, connectivity
        )
        complexes.append(Complex(
            elements=list(range(n)),
            phi=full_phi,
            complex_type=ComplexType.MAIN_COMPLEX,
        ))

        # Check subsets of size >= 2 (limited for performance)
        max_subset_check = min(n, 6)
        for size in range(2, max_subset_check):
            for subset in self._engine._combinations(list(range(n)), size):
                phi = self._engine.compute_phi_for_subset(
                    subset, system_state, connectivity
                )
                if phi > 0:
                    complexes.append(Complex(
                        elements=subset,
                        phi=phi,
                        complex_type=ComplexType.SUB_COMPLEX,
                    ))

        return complexes

    def to_dict(self) -> Dict[str, Any]:
        """Convert current state to dictionary."""
        return {
            "form_id": self.FORM_ID,
            "form_name": self.FORM_NAME,
            "is_initialized": self._is_initialized,
            "computation_count": self._computation_count,
            "last_phi": round(self._phi_history[-1], 6) if self._phi_history else None,
            "average_phi": round(sum(self._phi_history) / len(self._phi_history), 6) if self._phi_history else None,
            "last_output": self._last_output.to_dict() if self._last_output else None,
        }

    def get_status(self) -> IITSystemStatus:
        """Get current system status."""
        avg_phi = sum(self._phi_history) / len(self._phi_history) if self._phi_history else 0.0
        return IITSystemStatus(
            is_initialized=self._is_initialized,
            last_computation=self._last_output,
            computation_count=self._computation_count,
            average_phi=avg_phi,
            system_health=1.0 if self._is_initialized else 0.5,
        )


# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def create_iit_interface() -> IITConsciousnessInterface:
    """Create and return an IIT consciousness interface."""
    return IITConsciousnessInterface()


def create_simple_iit_input(
    num_elements: int = 4,
    connectivity_strength: float = 0.5,
    active_ratio: float = 0.5
) -> IITInput:
    """Create a simple IIT input for testing."""
    import random
    state = [1 if random.random() < active_ratio else 0 for _ in range(num_elements)]
    connectivity = [
        [connectivity_strength if i != j else 0.0 for j in range(num_elements)]
        for i in range(num_elements)
    ]
    labels = [f"element_{i}" for i in range(num_elements)]
    return IITInput(
        system_state=state,
        connectivity_matrix=connectivity,
        element_labels=labels,
    )


__all__ = [
    # Enums
    "IntegrationLevel",
    "ComplexType",
    "CauseEffectStructure",
    "PartitionType",
    "ExperienceQuality",
    # Input dataclasses
    "SystemElement",
    "IITInput",
    "Partition",
    # Output dataclasses
    "Concept",
    "ConceptualStructure",
    "Complex",
    "IITOutput",
    "IITSystemStatus",
    # Engine
    "IITComputationEngine",
    # Main interface
    "IITConsciousnessInterface",
    # Convenience functions
    "create_iit_interface",
    "create_simple_iit_input",
]
