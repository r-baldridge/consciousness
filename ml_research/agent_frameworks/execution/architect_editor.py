"""
Architect-Editor Pattern for Agent Execution.

Implements the separation of planning (architect mode) from execution (editor mode),
allowing for careful deliberation before side effects. Inspired by OpenCode's
approach to safe and deliberate code changes.

The pattern ensures:
    - Plans can be reviewed before execution
    - Side effects are isolated to execution phase
    - Complex tasks are broken into reviewable steps
    - Dependencies between steps are tracked

Example:
    backend = AnthropicBackend(api_key="...")
    arch_edit = ArchitectEditor(backend)

    # Plan without side effects
    plan = await arch_edit.plan(
        task="Add user authentication to the API",
        context="Flask application with SQLite database"
    )

    # Review and optionally modify plan
    if plan.requires_approval:
        print(plan.reasoning)
        # User approves...

    # Execute the plan
    result = await arch_edit.execute(plan, tools)
"""

from dataclasses import dataclass, field
from typing import List, Optional, Any, Dict, Protocol, AsyncIterator
from enum import Enum
import asyncio
import json
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class ExecutionMode(Enum):
    """Modes of operation for the architect-editor system."""

    ARCHITECT = "architect"  # Planning only, no side effects
    EDITOR = "editor"  # Execute changes
    ASK = "ask"  # Answer questions only
    CODE = "code"  # Direct coding without planning


@dataclass
class PlanStep:
    """A single step in an execution plan."""

    description: str
    tool: Optional[str] = None
    arguments: Optional[Dict[str, Any]] = None
    dependencies: List[int] = field(default_factory=list)  # Indices of steps this depends on
    estimated_impact: str = "low"  # low/medium/high
    rationale: str = ""
    expected_output: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert step to dictionary for serialization."""
        return {
            "description": self.description,
            "tool": self.tool,
            "arguments": self.arguments,
            "dependencies": self.dependencies,
            "estimated_impact": self.estimated_impact,
            "rationale": self.rationale,
            "expected_output": self.expected_output,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PlanStep":
        """Create step from dictionary."""
        return cls(
            description=data["description"],
            tool=data.get("tool"),
            arguments=data.get("arguments"),
            dependencies=data.get("dependencies", []),
            estimated_impact=data.get("estimated_impact", "low"),
            rationale=data.get("rationale", ""),
            expected_output=data.get("expected_output", ""),
        )


@dataclass
class ExecutionPlan:
    """A complete execution plan generated by the architect."""

    goal: str
    steps: List[PlanStep]
    files_to_modify: List[str]
    files_to_create: List[str]
    requires_approval: bool
    reasoning: str
    created_at: datetime = field(default_factory=datetime.now)
    plan_id: str = ""
    estimated_duration: Optional[str] = None
    risk_assessment: str = ""
    rollback_strategy: str = ""

    def __post_init__(self):
        """Generate plan_id if not provided."""
        if not self.plan_id:
            self.plan_id = f"plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{id(self)}"

    def to_dict(self) -> Dict[str, Any]:
        """Convert plan to dictionary for serialization."""
        return {
            "plan_id": self.plan_id,
            "goal": self.goal,
            "steps": [step.to_dict() for step in self.steps],
            "files_to_modify": self.files_to_modify,
            "files_to_create": self.files_to_create,
            "requires_approval": self.requires_approval,
            "reasoning": self.reasoning,
            "created_at": self.created_at.isoformat(),
            "estimated_duration": self.estimated_duration,
            "risk_assessment": self.risk_assessment,
            "rollback_strategy": self.rollback_strategy,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExecutionPlan":
        """Create plan from dictionary."""
        return cls(
            plan_id=data["plan_id"],
            goal=data["goal"],
            steps=[PlanStep.from_dict(s) for s in data["steps"]],
            files_to_modify=data["files_to_modify"],
            files_to_create=data["files_to_create"],
            requires_approval=data["requires_approval"],
            reasoning=data["reasoning"],
            created_at=datetime.fromisoformat(data["created_at"]),
            estimated_duration=data.get("estimated_duration"),
            risk_assessment=data.get("risk_assessment", ""),
            rollback_strategy=data.get("rollback_strategy", ""),
        )

    def get_execution_order(self) -> List[int]:
        """
        Get steps in valid execution order respecting dependencies.

        Returns:
            List of step indices in topological order.

        Raises:
            ValueError: If circular dependencies are detected.
        """
        n = len(self.steps)
        visited = [False] * n
        in_stack = [False] * n
        order = []

        def dfs(idx: int) -> None:
            if in_stack[idx]:
                raise ValueError(f"Circular dependency detected at step {idx}")
            if visited[idx]:
                return
            in_stack[idx] = True
            for dep in self.steps[idx].dependencies:
                if 0 <= dep < n:
                    dfs(dep)
            in_stack[idx] = False
            visited[idx] = True
            order.append(idx)

        for i in range(n):
            if not visited[i]:
                dfs(i)

        return order


@dataclass
class StepResult:
    """Result of executing a single step."""

    step_index: int
    success: bool
    output: Any = None
    error: Optional[str] = None
    duration_ms: int = 0
    tool_result: Optional[Any] = None


@dataclass
class ExecutionResult:
    """Result of executing a complete plan."""

    plan_id: str
    success: bool
    step_results: List[StepResult]
    total_duration_ms: int
    error: Optional[str] = None
    summary: str = ""
    artifacts: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary."""
        return {
            "plan_id": self.plan_id,
            "success": self.success,
            "step_results": [
                {
                    "step_index": sr.step_index,
                    "success": sr.success,
                    "output": sr.output,
                    "error": sr.error,
                    "duration_ms": sr.duration_ms,
                }
                for sr in self.step_results
            ],
            "total_duration_ms": self.total_duration_ms,
            "error": self.error,
            "summary": self.summary,
            "artifacts": self.artifacts,
        }


class LLMBackend(Protocol):
    """Protocol for LLM backends used by ArchitectEditor."""

    async def generate(
        self,
        prompt: str,
        system: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: int = 4096,
    ) -> str:
        """Generate a response from the LLM."""
        ...

    async def stream(
        self,
        prompt: str,
        system: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: int = 4096,
    ) -> AsyncIterator[str]:
        """Stream a response from the LLM."""
        ...


class ToolRegistry(Protocol):
    """Protocol for tool registries."""

    def get_tool(self, name: str) -> Optional[Any]:
        """Get a tool by name."""
        ...

    async def execute_tool(self, name: str, arguments: Dict[str, Any]) -> Any:
        """Execute a tool with given arguments."""
        ...

    def list_tools(self) -> List[str]:
        """List available tool names."""
        ...


class ArchitectEditor:
    """
    Separates planning (architect) from execution (editor) phases.

    The architect phase generates a detailed plan without any side effects.
    The editor phase executes the plan with full tool access.

    This separation allows for:
        - Human review of plans before execution
        - Safe exploration of solution strategies
        - Audit trails of planned vs actual actions
        - Rollback capabilities through explicit planning

    Attributes:
        backend: LLM backend for generating plans and reasoning
        mode: Current execution mode
        planning_temperature: Temperature for planning (lower = more deterministic)
        execution_temperature: Temperature for execution guidance
    """

    ARCHITECT_SYSTEM_PROMPT = """You are an AI architect planning code changes.
Your role is to create detailed, safe, and well-reasoned execution plans.

Guidelines:
1. Break complex tasks into small, atomic steps
2. Identify all files that need to be modified or created
3. Consider dependencies between steps
4. Assess risk and impact of each step
5. Provide clear rationale for each decision
6. Plan for error handling and rollback

Output your plan in the following JSON format:
{
    "goal": "The high-level goal",
    "reasoning": "Your overall reasoning and approach",
    "risk_assessment": "Assessment of risks and mitigations",
    "rollback_strategy": "How to undo changes if needed",
    "files_to_modify": ["list", "of", "files"],
    "files_to_create": ["new", "files"],
    "requires_approval": true/false,
    "estimated_duration": "estimated time",
    "steps": [
        {
            "description": "What this step does",
            "tool": "tool_name or null",
            "arguments": {"arg": "value"} or null,
            "dependencies": [indices of dependent steps],
            "estimated_impact": "low/medium/high",
            "rationale": "Why this step is needed",
            "expected_output": "What we expect to happen"
        }
    ]
}"""

    def __init__(
        self,
        backend: LLMBackend,
        planning_temperature: float = 0.3,
        execution_temperature: float = 0.7,
    ):
        """
        Initialize the ArchitectEditor.

        Args:
            backend: LLM backend for generating plans
            planning_temperature: Temperature for planning phase (default 0.3)
            execution_temperature: Temperature for execution guidance (default 0.7)
        """
        self.backend = backend
        self.mode = ExecutionMode.ARCHITECT
        self.planning_temperature = planning_temperature
        self.execution_temperature = execution_temperature
        self._plan_history: List[ExecutionPlan] = []
        self._execution_history: List[ExecutionResult] = []

    async def plan(
        self,
        task: str,
        context: str,
        available_tools: Optional[List[str]] = None,
        constraints: Optional[List[str]] = None,
    ) -> ExecutionPlan:
        """
        Generate an execution plan without side effects.

        This method operates in architect mode, creating a detailed plan
        that can be reviewed before execution.

        Args:
            task: The task to plan for
            context: Current context (file contents, project state, etc.)
            available_tools: List of available tool names
            constraints: Any constraints on the plan

        Returns:
            ExecutionPlan with steps, file lists, and reasoning
        """
        self.mode = ExecutionMode.ARCHITECT

        prompt = f"""Task: {task}

Context:
{context}

Available Tools: {json.dumps(available_tools or [])}

Constraints:
{json.dumps(constraints or ["None specified"])}

Create a detailed execution plan for this task."""

        try:
            response = await self.backend.generate(
                prompt=prompt,
                system=self.ARCHITECT_SYSTEM_PROMPT,
                temperature=self.planning_temperature,
                max_tokens=4096,
            )

            # Parse JSON from response
            plan_data = self._extract_json(response)
            plan = self._parse_plan(plan_data)
            self._plan_history.append(plan)

            logger.info(f"Generated plan {plan.plan_id} with {len(plan.steps)} steps")
            return plan

        except Exception as e:
            logger.error(f"Planning failed: {e}")
            # Return a minimal error plan
            return ExecutionPlan(
                goal=task,
                steps=[],
                files_to_modify=[],
                files_to_create=[],
                requires_approval=True,
                reasoning=f"Planning failed: {e}",
                risk_assessment="Unknown - planning failed",
                rollback_strategy="N/A",
            )

    async def execute(
        self,
        plan: ExecutionPlan,
        tools: ToolRegistry,
        stop_on_error: bool = True,
        progress_callback: Optional[callable] = None,
    ) -> ExecutionResult:
        """
        Execute the plan using available tools.

        Switches to editor mode and executes each step in dependency order.

        Args:
            plan: The execution plan to run
            tools: Tool registry for executing steps
            stop_on_error: Whether to stop on first error (default True)
            progress_callback: Optional callback(step_index, step, result)

        Returns:
            ExecutionResult with step results and summary
        """
        self.mode = ExecutionMode.EDITOR
        start_time = datetime.now()
        step_results: List[StepResult] = []

        try:
            execution_order = plan.get_execution_order()
        except ValueError as e:
            return ExecutionResult(
                plan_id=plan.plan_id,
                success=False,
                step_results=[],
                total_duration_ms=0,
                error=str(e),
                summary="Failed to determine execution order due to circular dependencies",
            )

        completed_steps: Dict[int, StepResult] = {}

        for step_idx in execution_order:
            step = plan.steps[step_idx]
            step_start = datetime.now()

            # Check dependencies
            deps_met = all(
                dep in completed_steps and completed_steps[dep].success
                for dep in step.dependencies
            )

            if not deps_met:
                result = StepResult(
                    step_index=step_idx,
                    success=False,
                    error="Dependencies not satisfied",
                )
                step_results.append(result)
                completed_steps[step_idx] = result
                if stop_on_error:
                    break
                continue

            # Execute step
            try:
                if step.tool:
                    tool_result = await tools.execute_tool(
                        step.tool, step.arguments or {}
                    )
                    output = tool_result
                else:
                    # Non-tool step (documentation, planning substep, etc.)
                    output = f"Completed: {step.description}"

                duration = int((datetime.now() - step_start).total_seconds() * 1000)
                result = StepResult(
                    step_index=step_idx,
                    success=True,
                    output=output,
                    duration_ms=duration,
                    tool_result=tool_result if step.tool else None,
                )

            except Exception as e:
                duration = int((datetime.now() - step_start).total_seconds() * 1000)
                result = StepResult(
                    step_index=step_idx,
                    success=False,
                    error=str(e),
                    duration_ms=duration,
                )
                logger.error(f"Step {step_idx} failed: {e}")

            step_results.append(result)
            completed_steps[step_idx] = result

            if progress_callback:
                try:
                    progress_callback(step_idx, step, result)
                except Exception:
                    pass

            if not result.success and stop_on_error:
                break

        total_duration = int((datetime.now() - start_time).total_seconds() * 1000)
        all_success = all(sr.success for sr in step_results)

        execution_result = ExecutionResult(
            plan_id=plan.plan_id,
            success=all_success,
            step_results=step_results,
            total_duration_ms=total_duration,
            summary=self._generate_summary(plan, step_results),
        )

        self._execution_history.append(execution_result)
        return execution_result

    async def architect_then_edit(
        self,
        task: str,
        context: str,
        tools: ToolRegistry,
        auto_approve: bool = False,
        approval_callback: Optional[callable] = None,
    ) -> ExecutionResult:
        """
        Full flow: plan -> approve -> execute.

        This is the main entry point for the architect-editor workflow.

        Args:
            task: The task to accomplish
            context: Current context
            tools: Tool registry
            auto_approve: Automatically approve all plans (default False)
            approval_callback: Optional async callback(plan) -> bool for approval

        Returns:
            ExecutionResult from the execution phase
        """
        # Phase 1: Architect
        plan = await self.plan(
            task=task,
            context=context,
            available_tools=tools.list_tools(),
        )

        # Phase 2: Approval
        if plan.requires_approval and not auto_approve:
            if approval_callback:
                approved = await approval_callback(plan)
                if not approved:
                    return ExecutionResult(
                        plan_id=plan.plan_id,
                        success=False,
                        step_results=[],
                        total_duration_ms=0,
                        error="Plan rejected by user",
                        summary="Execution cancelled: plan was not approved",
                    )
            else:
                logger.warning(
                    f"Plan {plan.plan_id} requires approval but no callback provided"
                )

        # Phase 3: Execute
        return await self.execute(plan, tools)

    async def ask(self, question: str, context: str) -> str:
        """
        Answer a question without planning or execution.

        Operates in ASK mode for pure question-answering.

        Args:
            question: The question to answer
            context: Relevant context

        Returns:
            Answer string
        """
        self.mode = ExecutionMode.ASK

        prompt = f"""Question: {question}

Context:
{context}

Please provide a helpful, accurate answer based on the context provided."""

        return await self.backend.generate(
            prompt=prompt,
            temperature=self.execution_temperature,
        )

    async def direct_code(
        self, task: str, context: str, tools: ToolRegistry
    ) -> ExecutionResult:
        """
        Execute code changes directly without detailed planning.

        For simple, low-risk changes that don't need full planning.

        Args:
            task: The coding task
            context: Current context
            tools: Tool registry

        Returns:
            ExecutionResult
        """
        self.mode = ExecutionMode.CODE

        # Create a minimal plan
        plan = ExecutionPlan(
            goal=task,
            steps=[
                PlanStep(
                    description=task,
                    tool=None,
                    estimated_impact="low",
                )
            ],
            files_to_modify=[],
            files_to_create=[],
            requires_approval=False,
            reasoning="Direct code mode - minimal planning",
        )

        return await self.execute(plan, tools)

    def get_plan_history(self) -> List[ExecutionPlan]:
        """Get history of generated plans."""
        return self._plan_history.copy()

    def get_execution_history(self) -> List[ExecutionResult]:
        """Get history of execution results."""
        return self._execution_history.copy()

    def _extract_json(self, response: str) -> Dict[str, Any]:
        """Extract JSON from LLM response."""
        # Try to find JSON block
        import re

        # Look for ```json ... ``` block
        json_match = re.search(r"```(?:json)?\s*([\s\S]*?)```", response)
        if json_match:
            return json.loads(json_match.group(1))

        # Try parsing entire response as JSON
        try:
            return json.loads(response)
        except json.JSONDecodeError:
            pass

        # Look for { ... } block
        brace_match = re.search(r"\{[\s\S]*\}", response)
        if brace_match:
            return json.loads(brace_match.group(0))

        raise ValueError("Could not extract JSON from response")

    def _parse_plan(self, data: Dict[str, Any]) -> ExecutionPlan:
        """Parse plan data into ExecutionPlan object."""
        steps = [
            PlanStep(
                description=s.get("description", ""),
                tool=s.get("tool"),
                arguments=s.get("arguments"),
                dependencies=s.get("dependencies", []),
                estimated_impact=s.get("estimated_impact", "low"),
                rationale=s.get("rationale", ""),
                expected_output=s.get("expected_output", ""),
            )
            for s in data.get("steps", [])
        ]

        return ExecutionPlan(
            goal=data.get("goal", ""),
            steps=steps,
            files_to_modify=data.get("files_to_modify", []),
            files_to_create=data.get("files_to_create", []),
            requires_approval=data.get("requires_approval", True),
            reasoning=data.get("reasoning", ""),
            estimated_duration=data.get("estimated_duration"),
            risk_assessment=data.get("risk_assessment", ""),
            rollback_strategy=data.get("rollback_strategy", ""),
        )

    def _generate_summary(
        self, plan: ExecutionPlan, results: List[StepResult]
    ) -> str:
        """Generate a human-readable summary of execution."""
        successful = sum(1 for r in results if r.success)
        failed = sum(1 for r in results if not r.success)
        total = len(results)

        return (
            f"Execution of '{plan.goal}': "
            f"{successful}/{total} steps succeeded, {failed} failed. "
            f"Files modified: {len(plan.files_to_modify)}, "
            f"Files created: {len(plan.files_to_create)}"
        )
